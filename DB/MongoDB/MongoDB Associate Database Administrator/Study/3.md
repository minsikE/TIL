# 3주차
## Unit 8. MongoDB Indexes
### Lesson 1. Using MongoDB Indexes in Collections
#### What indexes are

- Special data structures for fast data retrieval
- Store small portion of the data
- Ordered and easy to search efficiently
- Point to the document identity
- allow you to look up access and update data faster
- Support equality matches and range-based operations and return sorted results

#### How indexes can improve performance

- Speed up queries
- Reduce disk I/O
- Reduce resources required
- With indexes, MongoDB only fetches the documents identified by the index based on the query.
- Returns results faster
- There is one default index per collection, which includes only the _id field.
- Every query should use an index
- cursor.explain(”executionStats”)
    - 인덱스를 이용한 쿼리의 효과를 이해하는데 도움
        - nReturned : 반환받은 결과의 개수
        - totalDocsExamined : 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트 개수
        - executionTimeMillis : 쿼리 계획 선택과 쿼리 실행에 필요한 총 시간(밀리초 단위)

##### Without indexes

- MongoDB reads all documents (`Collection Scan`)
- Sorts results in memory

#### Costs of using indexes

- If we insert or update documents, we need to update the index data structure
- Delete unnecessary or redundant indexes

#### Most common index types

##### Single field

- Indexes on one field only

##### Compound

- Indexes include more than one field in the index.

##### Multikey indexes operate on an array field

- Each array entry has a corresponding index entry.

---

#### Quiz.

1. **Which of the following statements about indexes are correct? (Select all the that apply.)**
- **A.** Indexes are data structures that improve performance, support efficient equality matches and range-based query operations, and can return sorted results.
    
    **Correct.**
    
    Indexes are data structures that improve performance, support efficient equality matches and range-based query operations, and can return sorted results. Indexes achieve this by allowing MongoDB to perform only the work necessary to return the data that is requested, rather than scanning the entire collection.
    
- **B.** Indexes are automatically created based on usage patterns.
    
    **Incorrect.**
    
    While users can create indexes on the data that's used most often to help improve the performance of a slow query, indexes are not automatically created based on usage patterns. However, MongoDB Atlas provides recommendations about which indexes to create or drop.
    
- **C.** Indexes are used to make querying faster for users. One of the easiest ways to improve the performance of a slow query is create indexes on the data that is used most often.
    
    **Correct.**
    
    Indexes help make querying faster for users by only scanning the indexes to find the data that is requested.
    
- **D.** When using an index, MongoDB reads every document in a collection to check if it matches the query that's being run.
    
    **Incorrect.**
    
    When indexes are available, MongoDB does not need to scan the entire collection to return the data that is requested by a query. Instead, MongoDB will only scan the indexes to find the data that is requested.
    

2. **Which of the following statements about indexes are true? (Select one.)**
- **A.** Indexes improve query performance and have no impact on write performance.
    
    **Incorrect.**
    
    While indexes improve query performance, they do come with a cost. For example, any time you run a write operation, all the indexes must be updated, which can be time-consuming.
    
- **B.** Indexes improve query performance at the cost of write performance.
    
    **Correct!**
    
    Indexes improve query performance at the cost of write performance. For most use cases, this tradeoff is acceptable. Indexes should be used on data that is frequently queried or on queries that are infrequent but costly in terms of computational resources.
    
- **C.** Indexes have no impact on query performance but improve write performance.
    
    **Incorrect.**
    
    Indexes improve query performance by allowing the database to use indexes to speed up the query process. However, indexes do come with a cost. For example, any time you run a write operation, all the indexes must be updated, which can be time-consuming.
    
- **D.** Indexes have a negative impact on query performance but improve write performance.
    
    **Incorrect.**
    
    Indexes have a positive impact on query performance but come with a cost. For example, any time you run a write operation, all the indexes must be updated, which can be time-consuming.


### Lesson 2. Creating a Single Field Index in MongoDB
#### **A single field index**

- an index that supports efficient querying against a single field.
- By default, all collections have a single field index on the `_id` field,
- but users can define additional indexes that support important queries.
- A single field index is also a multikey index if the value of the field is an array.

##### Create a Single Field Index

- Use `createIndex()` to create a new index in a collection.
- Within the parentheses of `createIndex()`, include an object that contains the field and sort order.

```scss
// syntax
db.collection.createIndex({fieldname:1})

db.customers.createIndex({
  birthdate: 1 // ascending
})

// birthdate_1 생성됨
```

- createIndex 호출이 몇 초 후에 반환되지 않을 때
    - db.currentOp() 또는 mongod의 로그를 확인해 인덱스 구축의 진행률 체크 가능
        - db.currentOp()
            
            ```json
            	MongoServerError[AtlasError]: Error validating $currentOp value. arg=allUsers isn't allowed in this atlas tier
            ```
            
        - mongod 로그
            
            ```json
            {"t":{"$date":"2024-07-17T06:00:11.666Z"},"s":"I","c":"MONGOSH","id":1000000007,"ctx":"repl","msg":"Evaluating input","attr":{"input":"db.customers.createIndex({\nbirthdate: 1\n})"}}
            {"t":{"$date":"2024-07-17T06:00:11.668Z"},"s":"I","c":"MONGOSH","id":1000000011,"ctx":"shell-api","msg":"Performed API call","attr":{"method":"createIndex","class":"Collection","db":"sample_analytics","coll":"customers","arguments":{"keys":{"birthdate":1},"options":{}}}}
            ```
            

##### Create a Unique Single Field Index

- Add `{unique:true}` as a second, optional, parameter in `createIndex()` to force uniqueness in the index field values. Once the unique index is created, any inserts or updates including duplicated values in the collection for the index field/s will fail.

```scss
db.customers.createIndex({ email: 1 }, { unique:true })
```

- MongoDB only creates the unique index if there is no duplication in the field values for the index field/s.
    - MongoServerError: E11000 duplicate key error collection

##### View the Indexes used in a Collection

- Use `getIndexes()` to see all the indexes created in a collection.

```scss
db.customers.getIndexes()
```

- Atlas에서도 Collection 내 Index 확인 가능

##### Check if an index is being used on a query

- Use `explain()` in a collection when running a query to see the Execution plan.
- This plan provides the details of the execution stages (IXSCAN , COLLSCAN, FETCH, SORT, etc.).
    - The `IXSCAN` stage indicates the query is using an index and what index is being selected.
    - The `COLLSCAN` stage indicates a collection scan is perform, not using any indexes.
    - The `FETCH` stage indicates documents are being read from the collection.
    - The `SORT` stage indicates documents are being sorted in memory.

```scss
db.customers.explain().find({
  birthdate: {
    $gt:ISODate("1995-08-01")
    }
  })
```

```scss
db.customers.explain().find({
  birthdate: {
    $gt:ISODate("1995-08-01")
    }
  }).sort({
    email:1
    })
 
db.customers.explain().find({accounts:871666})
```

---

#### Quiz

1. **What is a single field index? (Select one.)**
- **A.** An index that supports efficient querying against one field
    
    **Correct.**
    
    A single field index is an index that supports efficient querying against a single field. By default, all collections have a single field index on the `_id` field, but users can define additional indexes that support important queries. A single field index is also a multikey index if the value of the field is an array.
    
- **B.** An index that supports efficient querying against multiple fields
    
    **Incorrect.**
    
    An index that supports efficient queries against multiple fields is called a compound index.
    
- **C.** An index that only supports efficient querying against fields with scalar values
    
    **Incorrect.**
    
    Single field indexes can also support efficient querying against a single array field.
    
- **D.** An index that supports efficient querying against fields that are already indexed by another user-defined index
    
    **Incorrect.**
    
    A single field index doesn't support efficient querying against fields that are already indexed by another user-defined index. When a single field is already indexed—for example, by a compound index—creating an additional single field index can cause over-indexing and performance issues.
    

2. **You have a collection of customer details. The following is a sample document from the collection:**

```json
{
  "_id": { "$oid": "5ca4bbcea2dd94ee58162a6a" },
  "username": "hillrachel",
  "name": "Katherine David",
  "address": "55711 Janet Plaza Apt. 865\nChristinachester, CT 62716",
  "birthdate": { "$date": { "$numberLong": "582848134000" } },
  "email": "timothy78@hotmail.com",
  "Accounts": [
    { "$numberInt": "462501" },
    { "$numberInt": "228290" },
    { "$numberInt": "968786" },
    { "$numberInt": "515844" },
    { "$numberInt": "377292" }
  ],
  "tier_and_details": {}
}
```

**You create a single field index on the email field, with the unique constraint set to true:**

```scss
db.customers.createIndex({email:1}, {unique:true})
```

**What would happen if you attempt to insert a new document with an email that already exists in the collection? (Select one.)**

- **A.** The new document will be inserted and replace the old document in the collection.
    
    **Incorrect.**
    
    That is not how the `unique` constraint operates. Unique indexes ensure that indexed fields do not store duplicate values. The new document will not be inserted in this example because the email address already exists in another document in the collection.
    
- **B.** The new document will be inserted and the old document will remain in the collection.
    
    **Incorrect.**
    
    That is not how the `unique` constraint operates. Unique indexes ensure that indexed fields do not store duplicate values. The new document will not be inserted in this example. Because the email address already exists in another document in the collection, the unique constraint would prevent the new document from being inserted.
    
- **C.** MongoDB will return a duplicate key error, and the document will be inserted.
    
    **Incorrect.**
    
    That is not how the `unique` constraint operates. Unique indexes ensure that indexed fields do not store duplicate values. While a duplicate error key would be returned, the new document would not be inserted in this example because the email address already exists in another document in the collection.
    
- **D.** MongoDB will return a duplicate key error, and the document will not be inserted.
    
    **Correct.**
    
    Unique indexes ensure that indexed fields do not store duplicate values. In this example, MongoDB will return a duplicate key error if you attempt to insert a new document with an email that already exists in the collection, as the `unique` constraint was set to `true`.

### Lesson 3. Creating a Multikey Index in MongoDB
#### Multikey indexes

- Index on an array field
- can index primitives, subdocuments, or subarrays.
- can be single field or compound index
    
    ```json
    // accounts 필드가 array일 경우
    db.customers.createIndex({accounts:1})
    db.customers.createIndex({email:1, accounts:1})
    
    // 모두 Multikey indexes라고 할 수 있
    ```
    
- There is a limitation of only one array field per index.

```json
// accounts index 생성 전 explain()으로 확인
db.customers.explain().find({accounts:627788})
// accounts index 생성
db.customers.createIndex({accounts:1})
// accounts index 생성 후 explain()으로 확인
db.customers.explain().find({accounts:627788})
```

---

#### Quiz

1. **What is a multikey index? (Select one.)**
- **A.** An index on one field only where the field is not an array
    
    **Incorrect.**
    
    A multikey index is any index where one of the indexed fields contains an array, including both single field and compound indexes. In a compound index, only one of the fields can be an array.
    
- **B.** An index where one of the indexed fields contains an array
    
    **Correct.**
    
    Multikey indexes support efficient queries against array fields by creating an index key for each element in the array. This allows MongoDB to search for the index key of each element in the array rather than scan the entire array, which results in dramatic performance gains in your queries.
    
- **C.** An index on more than one field where none of the fields are arrays
    
    **Incorrect.**
    
    A multikey index is any index where one of the indexed fields contains an array, including both single field and compound indexes. In a compound index, only one of the fields can be an array.
    
- **D.** An index on more than one field where multiple fields are arrays
    
    **Incorrect.**
    
    A multikey index is any index where one of the indexed fields contains an array, including both single field and compound indexes. In a compound index, only one of the fields can be an array.
    

2. **What is the maximum number of array fields per multikey index? (Select one.)**
- **A.** 1
    
    Correct! The maximum number of array fields per multikey index is 1. If an index has multiple fields, only one of them can be an array.
    
- **B.** 3
    
    Incorrect. The maximum number of array fields per multikey index is not 3. However, there is a limitation on the number of array fields per index.
    
- **C.** 5
    
    Incorrect. The maximum number of array fields per multikey index is not 5. However, there is a limitation on the number of array fields per index.
    
- **D.** Unlimited
    
    Incorrect. The maximum number of array fields per multikey index is not unlimited.

### Lesson 5. Deleting MongoDB Indexes
#### View the Indexes used in a Collection

- Use `getIndexes()` to see all the indexes created in a collection.
- There is always a default index in every collection on _id field.
- This index is used by MongoDB internally and cannot be deleted.

#### Delete an Index

- Indexes improve performance but have a write cost.
    - Too many indexes in a collection can affect system performance.
        - Delete unused or redundant indexes
    - Recreating an index takes time and resources
    - Hide the index before deleting it
        - db.collection.hideIndex(<index>)
        
        ```json
        db.customers.hideIndex('active_1_birthdate_-1_name_1')
        db.customers.hideIndex({active:1,birthdate:-1,name:1})
        ```
        
- Use `dropIndex()` to delete an existing index from a collection.
- Within the parentheses of `dropIndex()`, include an object representing the index key or provide the index name as a string.
    - Delete index by name:
        - db.customers.dropIndex(  'active_1_birthdate_-1_name_1' )
    - Delete index by key:
        - db.customers.dropIndex({  active:1,   birthdate:-1,   name:1 })

#### Delete Indexes

Use `dropIndexes()` to delete all the indexes from a collection, with the exception of the default index on _id.

```scss
db.customers.dropIndexes()
```

The `dropIndexes()` command also can accept an array of index names as a parameter to delete a specific list of indexes.

```sql
db.collection.dropIndexes('indexName')
db.collection.dropIndexes([ 'index1name', 'index2name', 'index3name' ])
```

---

#### Quiz

1. What are the ramifications of deleting an index that is supporting a query? (Select one.)
- **A.** The performance of the query will improve.
    
    **Incorrect.**
    
    Deleting an index that is supporting a query won’t improve the performance. However, it might cause MongoDB to have to scan the entire database to find the documents that match the query.
    
- **B.** The performance of the query will be negatively affected.
    
    **Correct!**
    
    The performance of the query will be negatively affected by the deletion of the only index that is currently supporting that query. Indexes generally improve the performance and time efficiency of queries by reducing the number of times that the database needs to be accessed.
    
- **C.** The query will fail.
    
    **Incorrect.**
    
    Deleting the only index that is supporting a query won't cause it to fail. However, it might cause MongoDB to have to scan the entire database to find the documents that match the query.
    
- **D.** The query will perform as expected.
    
    **Incorrect.**
    
    Deleting an index that is supporting a query will have an impact. It might cause MongoDB to have to scan the entire database to find the documents that match the query.
    

2. **You have a collection of customer details. The following is a sample document from this collection:**

```json
{
  "_id": { "$oid": "5ca4bbcea2dd94ee58162a6a" },
  "username": "hillrachel",
  "name": "Katherine David",
  "address": "55711 Janet Plaza Apt. 865\nChristinachester, CT 62716",
  "birthdate": { "$date": { "$numberLong": "582848134000" } },
  "email": "timothy78@hotmail.com",
  "Accounts": [
    { "$numberInt": "462501" },
    { "$numberInt": "228290" },
    { "$numberInt": "968786" },
    { "$numberInt": "515844" },
    { "$numberInt": "377292" }
  ],
  "tier_and_details": {}
}
```

**You have an index on the `email` field. Here’s the command you used to create the index:**

```scss
db.customers.createIndex({email:1})
```

**Before deleting it, you want to assess the impact of removing this index on the performance of the query. To do this, which command should you use? (Select one.)**

- **A.** dropIndex()
    
    **Incorrect.**
    
    The `dropIndex()` command deletes an index. Deleting the only index supporting a query will affect the performance of that query. You should hide the index before deleting it. This way, you'll be able to assess the impact of removing the index on query performance. What command is used to hide indexes?
    
- **B.** dropIndexes()
    
    **Incorrect.**
    
    The `dropIndexes()` command deletes multiple indexes. Deleting the only index supporting a query will affect the performance of that query. You should hide the index before deleting it. This way, you'll be able to assess the impact of removing the index on query performance. What command is used to hide indexes?
    
- **C.** getIndexes()
    
    **Incorrect.**
    
    The `getIndexes()` command returns an array that holds a list of documents that identify and describe the existing indexes on the collection, including hidden indexes. What command is used to hide indexes?
    
- **D.** hideIndex()
    
    **Correct.**
    
    The `hideIndex()` command hides an index. By hiding an index, you'll be able to assess the impact of removing the index on query performance. MongoDB does not use hidden indexes in queries but continues to update their keys. This allows you to assess if removing the index affects the query performance and unhide the index if needed. Unhiding an index is faster than recreating it. In this example, you would use the command `db.customers.hideIndex({email:1})`.

### Summary

- Single-field (one field)
- Compound (2 to 32 fields)

We worked with index properties like unique and understood that Multikey indexes are indexes that include one array field.

We used the following commands in the collection to create or delete indexes:

- createIndex()
- dropIndex()

Finally, we learned how to view the indexes being used in a collection with the `getIndexes()` command and how to check if the index is being used in a query by executing the `explain()` command.

#### Resources

Use the following resources to learn more about indexes in MongoDB:

##### Lesson 1 - Using MongoDB Indexes in Collections

- [MongoDB Docs: Indexes](https://www.mongodb.com/docs/manual/indexes/?_ga=2.67626584.810066485.1665291537-836515500.1666025886)
- [MongoDB Docs: Indexes Reference](https://www.mongodb.com/docs/manual/reference/indexes/?_ga=2.67626584.810066485.1665291537-836515500.1666025886)

##### Lesson 2 - Creating a Single Field Index in MongoDB

- [MongoDB Docs: createIndex()](https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/?_ga=2.67626584.810066485.1665291537-836515500.1666025886)
- [MongoDB Docs: Unique Indexes](https://www.mongodb.com/docs/manual/core/index-unique/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)
- [MongoDB Docs: Measure Index Use](https://www.mongodb.com/docs/manual/tutorial/measure-index-use/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)
- [MongoDB Docs: getIndexes()](https://www.mongodb.com/docs/manual/reference/method/db.collection.getIndexes/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)

##### Lesson 3 - Creating a Multikey Index in MongoDB

- [MongoDB Docs: Multikey Indexes](https://www.mongodb.com/docs/manual/core/index-multikey/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)

##### Lesson 4 - Working with Compound Indexes in MongoDB

- [MongoDB Docs: Compound Indexes](https://www.mongodb.com/docs/manual/core/index-compound/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)
- [MongoDB Docs: Indexing Strategies](https://www.mongodb.com/docs/manual/applications/indexes/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)

##### Lesson 5 - Deleting MongoDB Indexes

- [MongoDB Docs: dropIndex()](https://www.mongodb.com/docs/manual/reference/method/db.collection.dropIndex/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)
- [MongoDB Docs: dropIndexes()](https://www.mongodb.com/docs/manual/reference/method/db.collection.dropIndexes/?_ga=2.55479138.810066485.1665291537-836515500.1666025886)

## Unit 9. MongoDB Indexes II
### Lesson 1. How Indexes Work
#### How index values are stored

##### B-tree

- a self-balancing tree data structure that is well suited for general database indexing
- Unlike binary trees, nodes within a B-tree can have more than two child nodes
- sort their stored data in ascending sequential order, from left to right.

![bTree](resources/bTree.png)

#### How indexes work

![bTree1](resources/bTree1.png)

- MongoDB scanned more documents than it needed to.

![bTree2](resources/bTree2.png)

- By reordering the index keys, we’ve reduced the number of documents MongoDB needs to read

![bTree3](resources/bTree3.png)

- Index is not supporting our query sort operation, which forces MongoDB to do an in-memory sort.
    - It takes time and resources

![bTree4](resources/bTree4.png)

---

#### Quiz 

1. **Which of the following statements describe a B tree? (Select all that apply.)**
- **A.** B trees sort the stored data in ascending sequential order from left to right
    
    **Correct.**
    
    MongoDB stores the values of indexed fields using an optimized data structure known as a B tree. B trees sort their stored data in ascending sequential order, from left to right.
    
- **B.** Nodes in a B tree can have more than two child nodes
    
    **Correct.**
    
    MongoDB stores the values of indexed fields using an optimized data structure known as a B tree. Nodes in a B tree can have more than two child nodes.
    
- **C.** B tree stands for Binary tree
    
    **Incorrect.**
    
    MongoDB stores the values of indexed fields using an optimized data structure known as a B tree. B trees are self-balancing tree data structures, not binary tree structures.
    
- **D.** A B tree is a self-balancing tree data structure
    
    **Correct.**
    
    MongoDB stores the values of indexed fields using an optimized data structure known as a B tree. B trees are self-balancing tree data structures.
    
2. **Which index would most effectively support the following query? (Select one.)**

`db.collection.find({ username: "j0hnny", timestamp: { $gte: ISODate("2021-05-18T00:00:00.000Z"), $lt: ISODate("2021-05-18T13:00:00.000Z") }})`

**A.** `db.collection.createIndex({ username: 1, timestamp: 1 })`

**B.** `db.collection.createIndex({ timestamp: 1, username: 1 })`

**C.** `db.collection.createIndex({ username: 1 })`

**D.** `db.collection.createIndex({ timestamp: 1 })`

- **A.** Option A
    
    **Correct.**
    
    `db.collection.createIndex({ username: 1, timestamp: 1 })` is the most effective index for this query. This is because our equality match is the index prefix so MongoDB can quickly filter out the documents that don’t match before applying the range query.
    
- **B.** Option B
    
    **Incorrect.**
    
    `db.collection.createIndex({ timestamp: 1, username: 1 })` is not the most effective index for the given query. This index results in more index keys being scanned than documents returned due to the range query being the index prefix when we have an equality match in the query.
    
- **C.** Option C
    
    **Incorrect.**
    
    `db.collection.createIndex({ username: 1 })` is not the most effective index for the given query. This index will reduce the amount of documents scanned but we could improve it by making a compound index with the timestamp field.
    
- **D.** Option D
    
    **Incorrect.**
    
    `db.collection.createIndex({ timestamp: 1 })` is not the most effective index for the given query. This index will reduce the amount of documents scanned but we could improve it by making a compound index with the username field.
    

3. **Which index would most effectively support the following query? (Select one.)**

`db.collection.find({ timestamp: { $gte: ISODate("2021-05-18T00:00:00.000Z"), $lt: ISODate("2021-05-19T00:00:00.000Z") }, username: "j0hnny"}).sort({ rating: 1})`

**A.** `db.collection.createIndex({ timestamp: 1, username: 1, rating: 1 })`

**B.** `db.collection.createIndex({ username: 1, rating: 1, timestamp: 1 })`

**C.** `db.collection.createIndex({ rating: 1, timestamp: 1, username: 1 })`

**D.** `db.collection.createIndex({ rating: 1, username: 1, timestamp: 1 })`

- **A.** Option A
    
    **Incorrect.**
    
    This is not the most effective index for the given query. MongoDB will have to do an in-memory sort in order to get the correct results. Due to the order of the fields in this index, the documents that match the range filter will no longer be sorted when they get passed to the equality check. As a result, documents that match the name and range, need to be batched into memory and sorted, instead of the sorted results being returned directly from the index.
    
- **B.** Option B
    
    **Correct.**
    
    This is the most effective index for the given query. This index is using the equality field as the index predicate followed by the sort, and range. Putting the equality fields first in the index allows us to filter out documents before sorting or filtering, ideally eliminating 90% of possible document matches.. With the sort field second in the index, we can satisfy the sort request from the index without needing to do a blocking (in-memory) sort.
    
- **C.** Option C
    
    **Incorrect.**
    
    This is not the most effective index for the given query because this index has the sort as its predicate. Filtering based on the sort field first, we’re not able to avoid a blocking (in-memory) sort in subsequent stages.
    
- **D.** Option D
    
    **Incorrect.**
    
    This is not the most effective index for the given query because this index has the sort as its predicate. Filtering based on the sort field first, we’re not able to avoid a blocking (in-memory) sort in subsequent stages.
### Lesson 2. Index Usage Details via Explain
#### Explain():

- Syntax
    - db.collection.explain()
    - db.collection.find().explain()
    - db.collection.explain().help()

##### Information it provides

- The explain method returns information about an operations:
    - queryPlanner
        - the default verbosity mode for the explain method
        
        ```json
        db.collection.explain('queryPlanner').find({timestamp: {$gt: 2}, isActivated: true})
        db.collection.explain().find({timestamp: {$gt: 2}, isActivated: true})
        
        db.collection.find({timestamp: {$gt: 2}, isActivated: true}).explain().queryPlanner.winningPlan
        
        db.collection.find({timestamp: {$gt: 2}, isActivated: true}).explain().queryPlanner.rejectedPlans
        ```
        
        - Chooses and caches most efficient query plans
        - Cache stores entries in a least recently used(LRU) style for every collection
        - Cache entries are used for subsequent queries with same shape.
        - Least used entries are replaced when space is needed but can also be cleared by:
            - MongoDB system restart
            - Addition or removal of an index
            - Collection drop
            - db.collection.getPlanCache().clear()
    - executionStats
        
        ```json
        db.collection.explain('executionStats').find({timestamp: {$gt: 2}, isActivated: true}).sort({rating: -1})
        ```
        
        - queryPlanner 정보도 볼 수 있고 추가적으로 executionStats 정보가 나타난다.
            - nReturned : the number of documents that match the query condition.
            - executionTimeMillis : how long it took to select and exectue the plan.
            - totalKeysExamined : the number of index entries or keys that were scanned.
            - totalDocsExamined : the number of documents examined during query execution.
            - executionStages : in-memory sort or not
    - allPlansExecution
        
        ```json
        db.collection.explain('allPlansExecution').find({timestamp: {$gt: 2}, isActivated: true})
        ```
        
        - score : The higher the score, the more suitable the plan

##### Type of operations it can be used on

- find()
- findAndModify()
- findOneAndDelete()
- findOneAndReplace()
- findOneAndUpdate()
- update()
    - db.collection.explain().update()
        - Returns information about the write operation
        - But does not modify the database
- mapReduce()
- aggregate()
- distinct()
- count()
- remove()

---

#### Quiz

1. **From the following explain output, select the option that describes what the explain output it telling us: (Select one.)**

```jsx
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'sample_airbnb.listingsAndReviews',
    indexFilterSet: false,
    parsedQuery: {},
    queryHash: 'DD1CE27D',
    planCacheKey: 'DD1CE27D',
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'SORT',
      sortPattern: { host: -1 },
      memLimit: 104857600,
      type: 'simple',
      inputStage: { stage: 'COLLSCAN', direction: 'forward' }
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 5555,
    executionTimeMillis: 256,
    totalKeysExamined: 0,
    totalDocsExamined: 5555,
    executionStages: {
      stage: 'SORT',
      nReturned: 5555,
      executionTimeMillisEstimate: 130,
      works: 11113,
      advanced: 5555,
      needTime: 5557,
      needYield: 0,
      saveState: 13,
      restoreState: 13,
      isEOF: 1,
      sortPattern: { host: -1 },
      memLimit: 104857600,
      type: 'simple',
      totalDataSizeSorted: 100493513,
      usedDisk: false,
      spills: 0,
      inputStage: {
        stage: 'COLLSCAN',
        nReturned: 5555,
        executionTimeMillisEstimate: 0,
        works: 5557,
        advanced: 5555,
        needTime: 1,
        needYield: 0,
        saveState: 13,
        restoreState: 13,
        isEOF: 1,
        direction: 'forward',
        docsExamined: 5555
      }
    }
  },
  command: {
    find: 'listingsAndReviews',
    filter: {},
    sort: { host: -1 },
    '$db': 'sample_airbnb'
  },
  serverInfo: {
    host: 'M-C02GG1X2MD6M',
    port: 27017,
    version: '6.0.6',
    gitVersion: '26b4851a412cc8b9b4a18cdb6cd0f9f642e06aa7'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600
  },
  ok: 1
}

```

- **A.** The explain method was used in the allPlansExecution mode. An index on the host field was used.
    
    **Incorrect.**
    
    The example output was not the result of using the explain method in `allPlansExecution` mode. Additionally, the output doesn’t indicate that an index was used.
    
- **B.** The explain method was used in the default queryPlanner mode. The winning plan was an in memory SORT stage and the query wasn’t supported by an index.
    
    **Incorrect.**
    
    The provided output is not the result of using the explain method in the default, `queryPlanner`, mode. However, the winning plan was an in-memory `SORT` stage and was not supported by an index.
    
- **C.** The explain method was used in the executionStats mode. The query was not supported by an index. The winning plan was SORT, requiring an in memory sort to return the results in order.
    
    **Correct.**
    
    The provided explain output is the result of using the explain method in `executionStats` mode. This is made evident by the presence of the `executionStats` object in the output. Additionally, we could tell that the query wasn’t supported by an index, required an in-memory sort, and the winning plan was the `SORT` stage.
    
- **D.** The explain method was used in the executionStats mode.The query was supported by an index on the host field.
    
    **Incorrect.**
    
    The provided output is the result of using the `executionStats` mode with the explain method, however the output doesn’t tell us that the query was supported by an index on the `host` field.
    

2. **Which of the following fields can help us determine the effectiveness of an index? (Select all that apply.)**
- **A.** nReturned
    
    **Correct.**
    
    `nReturned` shows the number of documents that match the query condition. If the `nReturned` is less than the number of total documents and keys examined, our index can be improved. With an efficient index, the number of documents returned by a query is the same as the number of documents and keys examined.
    
- **B.** executionSuccess
    
    **Incorrect.**
    
    `executionSuccess` only informs us if our operation was executed.
    
- **C.** totalDocsExamined
    
    **Correct.**
    
    `totalDocsExamined` shows the number of documents examined during query execution. With an efficient index, the number of documents returned by a query is the same as the number of documents and keys examined.
    
- **D.** executionStages
    
    **Correct.**
    
    `executionStages` can help determine if MongoDB had to perform an in-memory sort. In the event that an in-memory sort, or blocking sort, is taking place, the `executionStages` array will contain a `SORT` stage. This means that MongoDB couldn’t rely on the index to satisfy the sort requested in the query.
    
- **E.** totalKeysExamined
    
    **Correct.**
    
    `totalKeysExamined` shows the number of index entries scanned. With an efficient index, the number of documents returned by a query is the same as the number of documents and keys examined.

### Lesson 3. Optimized Compound Indexes
#### Sample documents

```jsx
db.getSiblingDB("sample_game").users.insertMany([
  {
    _id: new ObjectId("6488bcfe84b99e26917f78b1"),
    dob: new Date("1987"),
    username: "testAccount",
    inactive: false,
    score: 800,
  },
  {
    _id: new ObjectId("6488bcfe84b99e26917f78b2"),
    dob: new Date("1988"),
    username: "exampleUser",
    inactive: false,
    score: 700,
  },
  {
    _id: new ObjectId("6488bcfe84b99e26917f78b3"),
    dob: new Date("1989"),
    username: "coolperson",
    inactive: true,
    score: 998,
  },
  {
    _id: new ObjectId("6488bcfe84b99e26917f78b4"),
    dob: new Date("1990"),
    username: "randomGuy",
    inactive: false,
    score: 500,
  },
])
```

---

#### Query

- To get a sorted list of current scores, for active users born between 1988 and 1990 sorted by current score in descending order, the following query was used:
    
    ```jsx
    db.users.find({
      dob: { $gte: new Date("1988"), $lte: new Date("1990") }, inactive: false
    }).sort({ current_score: -1 })
    ```
    

---

#### Break down the query into smaller parts

```jsx
db.users.find({
  dob:{ $gte: new Date("1988"), $lte: new Date("1990")
}}).explain('executionStats').executionStats

db.users.createIndex({ dob: 1 })

db.users.find({
  dob:{ $gte: new Date("1988"), $lte: new Date("1990")
}}).explain('executionStats').executionStats
```

```jsx
db.users.find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") }, inactive: false
}).explain('executionStats').executionStats

db.users.createIndex({ dob: 1, inactive: 1})

db.users.find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") }, inactive: false
}).explain('executionStats').executionStats

db.users.find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") },
  inactive: false,
}).hint({
  dob: 1, inactive: 1
}).explain("executionStats").executionStats

db.users.createIndex({ inactive: 1, dob: 1})

db.users.find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") },
  inactive: false,
}).explain("executionStats").executionStats
```

```jsx
db.users.find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") },
  inactive: false,
}).sort({ current_score: -1 }).explain("executionStats").executionStats

db.users.createIndex({ inactive: 1, current_score: 1 })

db.users.explain("executionStats").find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") },
  inactive: false,
}).sort({ current_score: -1 })

db.users.createIndex({ inactive: 1, current_score: 1, dob: 1 })

db.users.explain("executionStats").find({
  dob: { $gte: new Date("1988"), $lte: new Date("1990") },
  inactive: false,
}).sort({ current_score: -1 }).hint({ inactive: 1, current_score: 1, dob: 1 })
```

---

- An effective index is one where the number of documents returned, the number of keys examined, and the number of documents examined are the same.
- When would the number of keys examined > than the number of returned documents?
    - When MongoDB has to examine index keys even if they don’t match the query.
- If no optimal index, MongoDB chooses the one with the best score based on execution metrics.
- hint() forces MongoDB to use the given index.
- The optimal order for indexes is to put equality fields first (in any order), followed by range fields, and sort fields behind both equality and range.
    - ESR(Equality - Sort - Range)

##### In-memory sorts:

- Cost CPU and RAM
- Limit of 100 MB
    - allowDiskUse()
        - enables MongoDB to exceed the 100-megabyte limit for in-memory sorts by allowing temporary files to be written to disk.

- MongoDB traverses the inactive-score index in reverse
- Sorting the current scores in the correct order.
- Checks each document to make sure the date of birth is in range.

---

#### Quiz

1. **The `SORT` stage will be present in the `executionStages` object of the `explain('executionStats')` output if a blocking (in-memory) sort took place.**
- **A.** True
    
    **Correct.**
    
    The presence of the `SORT` stage in the `executionStages` object of the `explain('executionStats')` output means that MongoDB had to sort the documents in memory, which can be computationally expensive.
    
- **B.** False
    
    **Incorrect.**
    
    The `SORT` stage’s presence in the `executionStages` object of the `explain('executionStats')` output means that MongoDB had to sort the documents in memory, which can be computationally expensive.
    

2. **You check the `executionStats` for a query using an index and see the following output:**

```jsx
{
  executionSuccess: true,
  nReturned: 2,
  executionTimeMillis: 0,
  totalKeysExamined: 3,
  totalDocsExamined: 3,
…
}

```

**Which of the following is true? (Select all that apply.)**

- **A.** MongoDB had to scan an extra document
    
    **Correct.** `totalDocsExamined` is three while `nReturned` is two which means MongoDB scanned an extra document. The number of documents and index keys examined should be the same as the number of documents returned. If MongoDB examines more documents than it returns, this indicates that the index used by this query could be optimized further.
    
- **B.** Two documents were returned
    
    **Correct.** `nReturned` signifies that two documents were returned. In this example, MongoDB returns two documents but scans three. This indicates that the index used by this query could be optimized further since the number of documents and index keys examined should be the same as the number of documents returned.
    
- **C.** MongoDB had to scan an extra index key
    
    **Correct.**
    
    `totalKeysExamined` is three while `nReturned` is two which means MongoDB scanned an extra index key. This indicates that the index used by this query could be optimized further since the number of index keys examined, and the number of documents examined, should be the same as the number of documents returned.
    
- **D.** This query is not using an index
    
    **Incorrect.**
    
    We can tell that an index was used since three index keys were scanned according to the `totalKeysExamined` field.

### Lesson 4. Wildcard Indexes
#### What Wildcard Indexes are

- Support queries against unknown or arbitrary fields
- Create an index on all fields in each document of a collection
- Embedded Documents:
    - The wildcard index descends into the embedded document and indexes its contents
    - Continues traversing any additional nested documents until it reaches a primitive value
- Arrays:
    - The wildcard index traverses the array and indexes each element
- ObjectId
    - The wildcard index do not index _id field
        - wildcardProjection
- Can have multiple wildcard indexes per collection
- May cover the same fields as other indexes in the collection

#### Use cases

- Useful if you have very dynamic documents
- Datasets with dynamic schemas
- E.g.: IoT, metadata, weather services

#### How to create

```jsx
// 모든 필드 index
db.products.createIndex( { "$**" : 1 } )

db.products.createIndex({ "product_attributes.$**" : 1 })
```

#### Limitations

- Cannot use the unique or TTL options

#### Sample Documents

```jsx
db.getSiblingDB("sample_products").products.insertMany([
  {
    _id: new ObjectId("64a36318574fd20cd8fb9798"),
    sku: 111,
    product_name: "Stero Speakers",
    price: 100,
    stock: 5,
    product_attributes: { color: "black", size: "5x5x5", weight: "5lbs" },
  },
  {
    _id: new ObjectId("64a36318574fd20cd8fb9799"),
    sku: 121,
    product_name: "Bread",
    price: 2,
    stock: 50,
    product_attributes: {
      type: "white",
      calories: 100,
      weight: "24g",
      crust: "soft",
    },
  },
  {
    _id: new ObjectId("64a36318574fd20cd8fb979a"),
    sku: 131,
    product_name: "Milk",
    price: 3,
    stock: 20,
    product_attributes: {
      type: "2%",
      calories: 120,
      weight: "1L",
      brand: "Dairy Farmers",
    },
  },
]);

```

To create a wildcard index on the product attributes field, use the `db.collection.createIndex()` method, passing in the name of the field you want to index appended with a dot, dollar sign and two asterisks:

```scss

db.products.createIndex({ "product_attributes.color" : 1 })
db.products.createIndex({ "product_attributes.weight" : 1 })
db.products.createIndex({ "product_attributes.type" : 1 })
db.products.createIndex({ "product_attributes.crust" : 1 })

db.products.createIndex({ "product_attributes.$**" : 1 })
```

To test the query using the explain method, use dot notation to inspect the winning plan and confirm that the wildcard index is being used:

```scss
db.products.find({
  "product_attributes.crust": false,
}).explain().queryPlanner.winningPlan

```

To specify which fields to include or exclude in a wildcard index, set the value of a given field in a wildcard projection to `1` to include or `0` to exclude. To include the `_id`, while excluding the `stock`, and `price` fields, use the following command:

```scss
db.products.createIndex(
  { "$**": 1 },
  { wildcardProjection: { _id: 1, stock: 0, prices: 0 } }
)

```

To test the wildcard index with an query on the `sku` field, run the following query to return the `winningPlan` object from the explain output:

```scss
db.products.find({ sku: 111 }).explain().queryPlanner.winningPlan
```

To test the wildcard index even further, run another query on one of the product attribute fields, like so:

```scss
db.products.find({
  "product_attributes.crust": false
}).explain().queryPlanner.winningPlan

```

To create a compound wildcard index (starting in MongoDB 7.0) on the `stock` field and all of the product attributes fields, use the following command:

```scss
db.products.createIndex({
  stock: 1, "product_attributes.$**" : 1
})
```

---

#### Quiz

1. **Why should you use a wildcard index to support queries in a MongoDB collection instead of a regular index? (Select one.)**
- **A.** Wildcard indexes have a smaller storage footprint than regular indexes.
    
    **Incorrect.**
    
    Wildcard indexes do not have a smaller storage footprint over regular indexes.
    
- **B.** Wildcard indexes make queries that use regular expressions more efficient.
    
    **Incorrect.**
    
    Wildcard indexes are not more efficient for queries that use regular expressions.
    
- **C.** Wildcard indexes can support queries against any field, even if that field is unknown at the time of querying.
    
    **Correct.**
    
    Wildcard indexes allow queries against unknown or arbitrary fields to be supported by an index.
    
- **D.** Wildcard indexes allow for efficient querying against time-series data.
    
    **Incorrect.**
    
    Wildcard indexes do not offer any advantages for querying against time series data.
    
2. **Given the following query:**

```jsx
db.people.find({ "metadata.likes": "golfing", "metadata.age": 30 })
```

**Which of the following indexes would support all the fields in the query? (Select one.)**

**A.** `db.people.createIndex({ name: 1 })`

**B.** `db.people.createIndex({ metadata: 1})`

**C.** `db.people createIndex({ metadata.likes, metadata.status })`

**D.** `db.people.createIndex({ ‘metadata.$**’: 1 })`

- **A.** Option A
    
    **Incorrect.**
    
    The original query doesn’t include an equality, sort or range query involving the `name` field. Therefore this index wouldn’t support all the fields in the query.
    
- **B.** Option B
    
    **Incorrect.** While queries against the metadata field as a whole would be supported by a single field index on the metadata field, this query attempts to search the fields within it and therefore wouldn’t benefit from this index.
    
- **C.** Option C
    
    **Incorrect.**
    
    While the `metadata.likes` field would be supported by this index, it fails to support a query that included other fields within the metadata document.
    
- **D.** Option D
    
    **Correct.**
    
    A wildcard index on all sub-fields within the metadata document would support the query. Additionally, if we were to add other fields to the query that were contained in the metadata document, those would be supported by this index as well.